## G1GC

# G1 GC特点：
1.并行与并发，充分利用多核处理器优势，工作与应用线程并发执行，减少停顿时间

2.分区收集，将整个堆内存划分为多个大小相等的区域（Region），逻辑连续，物理可以不连续。每个Region都可以扮演Eden区、Survivor区、Old区等角色，使用更加灵活进行内存管理和垃圾收集。

3.优先回收垃圾最多区域，跟踪每个Region垃圾堆积情况，会根据回收价值和成本进行排序。

4.标记-整理算法，整体使用标记-整理算法回收内存，以减少内存碎片产生。在两个Region之间进行垃圾回收时，采用标记-复制算法，通过组合策略兼顾内存利用率和垃圾回收效率。

5.可预测的停顿时间，通过建立可预测的停顿模型，允许用户明确指定在一个特定时间片段内，垃圾收集的停顿时间不得超过某个阈值。

# G1 GC类型
根据用途和状态将Region分为不同类型：

1.自由分区，空闲，可以用于新对象分配

2.新生代分区，包括Eden和Survivor区，主要用于存储新创建的对象。

3.大对象分区，只要对象大小超过Region的一半，就被认为是大对象，会直接分配到大对象分区。且每个大对象都单独占用一个或者多个连续大对象分区。

4.老年代分区，用于存储长时间存活的对象。


![image](https://github.com/user-attachments/assets/d7e2e4c4-1272-4ed7-8e36-4784848a2461)

# 分区的回收和管理
G1收集器通过维护一个优先列表来跟踪各个Region中的垃圾堆积情况和回收价值，G1会根据这个列表优先回收价值最大的Region，这种策略能更有效的利用资源，最大限度的减少垃圾回收的停顿时间。更细粒度的内存管理和巨型对象的存在提高了内存的利用率，也能更好适应不同内存大小的垃圾回收需求。


#  G1回收过程
 1.初始标记（Initial Marking）：
 这个过程是STW（Stop-The-World）的，但通常耗时非常短。它标记出从GC Roots直接可达的对象，作为后续垃圾收集的基础。
 
 2. 并发标记（Concurrent Marking）：
 在初始标记完成后，G1 GC会进入并发标记阶段。这个阶段与应用程序线程并发执行，通过递归地追踪所有可达的对象，并将它们标记为存活。这个过程是并发的，因此不会阻塞应用程序的执行。
 
 3.最终标记（Final Marking）：
 为了处理在并发标记过程中新产生的对象引用关系，G1 GC会执行一次短暂的STW的最终标记。这个阶段确保所有在并发标记阶段漏掉的对象都被正确标记。
 
 4.筛选回收（Live Data Counting and Evacuation）：
 在这个阶段，G1 GC会根据每个Region的垃圾堆积情况和回收价值进行排序，并选择性地回收部分Region中的垃圾对象。回收过程包括将存活的对象从一个Region复制或移动到另一个Region，并更新相关的引用。这个过程也是并发的，旨在最大限度地减少停顿时间。同时，这个阶段可能会涉及到对象的整理和压缩，以减少内存碎片。

# G1 两种回收策略
1.Young GC（新生代回收）
Young GC主要负责回收新生代中的对象。新生代通常包含新创建的对象，这些对象更有可能在短时间内变成垃圾。Young GC的执行过程相对较快，因为它只涉及新生代中对象的扫描和回收。

在Young GC过程中，Eden区和Survivor区的存活对象会被复制到另一个Survivor区或者晋升到老年代。这个过程是Stop-The-World（STW）的，意味着在回收过程中，应用程序的所有线程都会被暂停。但是，由于新生代中的对象通常较少，因此这个暂停时间通常较短，对应用程序的性能影响也较小。

2. Mix GC（混合回收）
Mix GC则是G1收集器特有的回收策略，它不仅回收新生代中的所有Region，还会回收部分老年代中的Region。这种策略的目标是在保证停顿时间不超过预期的情况下，尽可能地回收更多的垃圾对象。

在Mix GC过程中，首先会进行全局并发标记（global concurrent marking），这个过程是并发的，与应用程序线程同时执行，用于标记出所有存活的对象。然后，在回收阶段，G1会根据标记结果选择收益较高的部分老年代Region和新生代Region一起进行回收。这个选择过程是基于对Region中垃圾对象的数量和回收价值的评估。

与Young GC不同，Mix GC的停顿时间可能会更长，因为它涉及到对老年代中对象的扫描和回收。但是，由于Mix GC能够回收更多的垃圾对象，因此它通常能够更有效地释放内存空间，减少垃圾堆积对应用程序性能的影响。

#  跨代引用和RSet（记忆集）
在垃圾收集过程中，跨代引用或跨Region引用是一个需要特别注意的现象：

 跨代引用的概念：
 在垃圾收集领域，跨代引用指的是不同代际之间的对象相互引用。在G1收集器中，由于堆被划分为多个Region，跨代引用通常表现为跨Region引用。年轻代指向老年代的引用在垃圾收集中不是主要问题，因为即使年轻代的对象被清理，程序仍然可以正常运行，且未被标记到的老年代对象会在后续的Major GC中被回收。
 
 老年代指向年轻代的引用问题：
 当存在老年代指向年轻代的引用时，情况就复杂了。在Minor GC阶段，我们不能简单地清理年轻代中的对象，因为老年代中可能还有对象持有对这些对象的引用。为了解决这个问题，我们需要一种机制来跟踪这些跨Region的引用。
 
 RSet（记忆集）的作用：
 RSet正是为了解决这个问题而设计的。它的主要作用是记录哪些Region中的老年代对象有指向年轻代的引用。在GC时，通过扫描这些Region中的RSet，我们可以快速识别出需要保留的年轻代对象，从而避免扫描整个老年代，显著提高了垃圾收集的效率。RSet的实现本质上是一种哈希表，其中Key是Region的起始地址，Value是一个集合，存储了卡表的索引号。
 RSet（RememberedSet）是一个非常重要的数据结构，用于记录并跟踪其他Region指向当前Region中对象的引用。在G1收集器的分区模型中，由于堆内存被划分为多个独立的Region，对象之间的引用关系可能跨越不同的Region。为了能够在垃圾收集过程中正确地识别和处理这些跨Region的引用，G1引入了RSet的概念。
 每个Region都有一个与之关联的RSet，用于记录其他Region中指向该Region内对象的引用信息。当发生对象引用关系变化时，G1会更新相应的RSet，以确保垃圾收集的准确性。在垃圾收集过程中，G1会利用RSet来快速确定哪些Region之间存在引用关系，从而避免不必要的全堆扫描，提高垃圾收集的效率。
 RSet的实现通常涉及一些优化技术，如使用位图（Bitmaps）或压缩表（CompressedTables）来紧凑地存储引用信息，以减少内存占用和提高访问速度。此外，G1还采用了一些策略来维护RSet的一致性，如在并发标记阶段使用写屏障（Write Barriers）来拦截并更新跨Region的引用。

 减少YGC时的扫描开销：
 由于新生代的垃圾收集通常很频繁（即YGC），如果每次都需要扫描整个老年代来确定是否有对新生代的引用，那么开销将会非常大。通过RSet的跟踪机制，我们可以精确地知道哪些老年代Region中的对象引用了新生代对象，从而只扫描这些Region，大大降低了YGC时的扫描开销。
 卡标记（Card Marking）技术与卡表（Card Table）：
 HotSpot JVM为了更高效地处理老年代到新生代的引用问题，采用了卡标记技术。具体来说，它使用了一个称为卡表（Card Table）的数据结构来辅助标记过程。堆空间被划分为一系列的卡页（Card Page），每个卡页对应卡表中的一个标记项。当发生对老年代到新生代引用的写操作时，通过写屏障（Write Barrier）机制来更新卡表中对应的标记项。这样，在GC时，我们只需要扫描那些被标记为dirty的卡页所对应的Region即可快速找到所有老年代到新生代的引用关系。


# 性能优化建议
 合理设置堆大小：根据应用程序的内存需求和硬件资源，合理设置JVM的堆大小。过大的堆可能会导致长时间的垃圾收集停顿，而过小的堆则可能导致频繁的垃圾收集。
 调整停顿时间目标：通过调整G1的停顿时间目标（-XX:MaxGCPauseMillis参数），可以平衡垃圾收集的效率和应用程序的响应时间。在需要低延迟的场景中，可以设置较短的停顿时间目标。
 启用并行垃圾收集线程：通过增加并行垃圾收集线程的数量（-XX:ParallelGCThreads参数），可以提高垃圾收集的效率。然而，过多的线程可能会导致系统资源的竞争和额外的开销，因此需要谨慎调整。
 优化对象分配和晋升策略：通过优化对象的分配和晋升策略，可以减少新生代和老年代之间的对象流动，从而降低垃圾收集的开销。例如，可以考虑使用对象池、缓存等技术来减少临时对象的创建和销毁。
 监控和分析GC日志：定期监控和分析GC日志可以帮助识别潜在的内存泄漏、性能瓶颈和优化机会。可以使用JVM自带的工具（如jstat、jvisualvm）或第三方工具（如GCViewer、YourKit）来进行日志分析和性能调优。


#  G1核心配置参数
在JDK9及以后的版本中，G1是默认的垃圾收集器，但在JDK8中，你需要显式地启用。以下是G1收集器的一些核心配置参数：

 -XX:+UseG1GC:
 这个参数用于启用G1垃圾收集器。在JDK8中，你需要明确设置这个参数来使用G1，而在JDK9及更高版本中，G1是默认启用的。
 
 -XX:G1HeapRegionSize:
 这个参数用于设置每个Region的大小。Region是G1收集器管理内存的基本单位。该值必须是2的幂，范围在1MB到32MB之间。G1的目标是根据最小的Java堆大小划分出约2048个这样的区域。默认情况下，这个值是堆内存的1/2000，这意味着G1收集器管理的最小堆内存应该是2GB以上，最大堆内存为64GB。
 
 -XX:MaxGCPauseMillis:
 这个参数用于设置期望的最大GC停顿时间指标。G1收集器会尽力在这个时间内完成垃圾回收，以减少应用程序的停顿时间。默认值是200毫秒。
 
 -XX:ParallelGCThreads:
 这个参数用于设置并行垃圾回收的线程数。这个值通常设置为与可用的CPU核心数相等，最大可以设置为8。
 
 -XX:ConcGCThreads:
 这个参数用于设置并发标记的线程数。并发标记是G1收集器在垃圾回收过程中的一个阶段，这个阶段与应用程序线程并发执行。通常，这个值设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。
 
 -XX:InitiatingHeapOccupancyPercent:
 这个参数用于设置触发并发GC周期的Java堆占用率阈值。当堆内存的占用率达到这个值时，G1收集器会启动一个并发GC周期。默认值是45%，这意味着当堆内存的45%被占用时，就会触发垃圾回收。
 
 -XX:+PrintGCDetails 和 -verbose:gc:
 这两个参数不是G1特有的，但它们对于调试和监控垃圾收集器的行为非常有用。-XX:+PrintGCDetails会打印详细的垃圾收集日志，包括每次垃圾收集的时间、回收的对象数量等信息。-verbose:gc则会启用垃圾收集的日志记录，通常与-XX:+PrintGCDetails一起使用以获取更全面的日志输出。


 ![image](https://github.com/user-attachments/assets/36b5073b-c8ed-46d3-8037-e54ee234d01e)



