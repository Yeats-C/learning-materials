#  学习底层原理：垃圾回收算法是如何设计的？


垃圾回收（Garbage Collection ，GC）引起关注，是从1995年java发布后开始的，事实上，gc作为计算机科学领域非常热门的研究话题之一，最早可追溯到1959年夏天。起初是用来简化lisp内存管理的。
在接下来的60余年时间里，通过cheney，baker等大师的不断努力，gc的世界里出现了标记清除、复制、分代、增量回收等一系列gc算法，基于这些算法，又出现了种类繁多的垃圾回收器。

## 什么是gc？
gc把程序不用的内存空间视为【垃圾】，（几乎所有的）gc要做的就两件事：
**1.找到内存空间中的垃圾，使其和活对象分开来。**
**2.回收垃圾对象的内存，使程序可以重发使用这些内存。**

gc给我们带来的好处不言而喻，选择gc而不是手动释放资源的原因很简单：程序比人更可靠。

## gc流派
gc从其底层实现方式（即gc算法）来看，主要分为两大类：基于可达性分析的gc和基于引用计数器的gc。当然，这样的分类并不绝对，现代很多gc设计就融合了引用计数和可达性分析两种。

**可达性分析法**
基本思路就是通过根集合（gc root）作为起始点，从这些节点出发，根据引用关系开始搜索，所经过的路径叫做引用链，当一个对象没有引用链访问到达时，则证明此对象是不活跃的，可以回收。
使用此类算法的有JVM、.NET、Golang等。

**引用计数法**
引用计算法没有用到根集概念，其基本原理是：在堆内存分配对象时，会为对象分配一段额外的空间，这个空间用于维护一个计数器，如果有一个新的引用指向这个对象，则计数器的值加1；
如果指向该对象的引用被空置或指向其他对象，则计数器的值减1.当计数器的值为0时，自动删除这个对象。使用此类算法的主要有Python、Object-C、Perl等。

基于可达性分析的Gc效率较高，实现起来比较简单（引用计数法是算法简单，实现较难），但其缺点是在Gc期间，整个应用需要被挂起，后面很多此类算法的提出，都是在解决这个问题（缩小STW时间）。

基于引用计数法的GC，天然带有增量特性，GC可与应用交替运行，不需要暂停应用；同时，在引用计数法中，每个对象始终知道自己的被引用数，当计数器为0时，对象可以马上回收，而在可达性分析类的GC中，
及时对象变成了垃圾，程序也无法立刻感知，直到GC执行前，始终都会有一部分内存空间被垃圾占用。

上述两类GC各有千秋，真正的工业级实现一般是这两种算法的结合。但总体来说，基于可达性分析的GC还是占据了主流。究其原因，引用计数算法无法解决【循环引用无法回收】的问题，及两个对象互相引用，
所有各对象的计数器的值都是1，即使这些对象都成了垃圾（无外部引用），GC也无法将其回收。引用计数算法最大的问题在于：计数器的增减处理非常繁重，比如对根对象的引用。此外，多个线程之间共享对象
时需要对计数器进行原子递增/递减，这本身又带来一系列新的复杂性和问题，计数器对应用程序的整体运行速度的影响。

## 垃圾回收算法：
**1.标记-清除算法**
**2.标记-压缩算法**
**3.标记-复制算法**
**4.分代算法**
**5.增量算法**
**6.并发算法**

前三种是最基础的算法，后面三种是对前面三种算法在某些方面的改进。了解到上述这些算法后，我们可以看到，现在的很多垃圾回收器，无非是是把文中提到的几种算法进行组合或取舍。
如 CMS 垃圾回收器，就是「标记-清除 + 并发算法」的组合，其全称 Concurrent Mark-Sweep 也表明了这一点，而 G1 是「标记-复制算法 + 增量算法 + 并发算法」的组合。

**标记-清除算法（Mark-Sweep）**
标记-清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段，有对象头标记和位图标记（bitmap marking）这两种方式，后者可以与写时复制技术（copy-on-write）相兼容。
清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段，回收时会把对象作为分块，连接到被称为「空闲链表（free-lis）」的链表中去。

清除操作并不总是在标记阶段结束后就全部完成的，一种「延迟清除（Lazy Sweep）」的算法可以缩减因清除操作导致的应用 STW 时间。延迟清除算法不是一下遍历整个堆（清除所花费的时间与堆大小成正比）
，它只在分配对象时执行必要的堆遍历，同时其算法复杂度只与活动对象集的大小成正比。

，标记-清除算法执行完成后，会让堆出现碎片化，这会带来两个问题：

大量的内存碎片会导致大对象分配时可能失败，从而提前触发了另一次垃圾回收动作；

具有引用关系的对象可能会被分配在堆中较远的位置，这会增加程序访问所需的时间，即「访问的局部性（Locality）」较差。

上述两个问题，将分别由下面介绍的标记-压缩算法和标记-复制算法来解决。

**标记-压缩算法（Mark-Compact）**
标记-压缩算法是在标记-清除算法的基础上，用「压缩」取代了「清除」这个回收过程，如下图所示，GC 将已标记并处于活动状态的对象移动到了内存区域的起始端，然后清理掉了端边界之外的内存空间。

压缩阶段需要重新安排可达对象的空间位置（reloacate）以及对移动后的对象引用重定向（remap），这两个过程都需要搜索数次堆来实现，因此会增加了 GC 暂停的时间。标记-压缩算法的好处是显而易见的：
在进行这种压缩操作之后，新对象的分配会变得非常方便——通过指针碰撞即可实现。与此同时，因为 GC 总是知道可用空间的位置，因此也不会带来碎片的问题。

标记-压缩算法算法还有很多变种，如 Robert A. Saunders 研究出来的名为 Two-Finger 的压缩算法（论文：The LISP system for the Q-32 computer. In The Programming Language LISP: Its
Operation and Applications[4]），可以把堆搜索的次数缩短到2次， Stephen M. Blackburn 等研究出来的 ImmixGC 算法（论文：Cyclic reference counting with lazy mark-scan[5]）
结合了标记-清除和标记-压缩两种算法，可以有效地解决碎片化问题。

**标记-复制算法（Mark-Copy）**
标记-复制算法与标记-压缩算法非常相似，因为它们会对活动对象重新分配（reloacate）空间位置。两个算法区别是：在标记-复制算法中，reloacate 目标是一个不同的内存区域。

标记清除算法的优点很多，譬如：

不会发生碎片化
优秀的吞吐率
可实现高速分配
良好的 locality

对比算法执行前后堆空间的变化，可以看到，不难发现标记-复制算法最大缺点在于所需空间翻倍了，即堆空间的利用率很低。

标记-复制在复制阶段，需要递归复制对象和它的子对象，递归调用带来的开销是不容忽视的。C. J. Cheney 于 1970 年研究出了迭代版本的复制算法，可以抑制调用函数的额外负担和栈的消耗
，感兴趣的同学可以参考论文：A Nonrecursive List Compacting Algorithm[6]。

垃圾回收算法的改进

下面介绍的三种垃圾回收算法，会针对基础算法中诸如堆碎片化、暂停时间过长、空间利用率不高等不足进行改进。

**分代算法（Generational GC）**
分代算法对基础算法的改进主要体现在该算法减小了 GC 的作用范围。如前所述，标记过程和对象的 reloacate 过程都需要完全停止应用程序进行堆搜索，堆空间越大，进行垃圾回收所需的时间就越长，
如果 GC 的堆空间变小，应用暂停时间也会相应地降低。

分代算法基于这样一个假说（Generational Hypothesis）：绝大多数对象都是朝生夕灭的，该假说已经在各种不同类型的编程范式或者编程语言中得到证实了。分代算法把对象分类成几代，
针对不同的代使用不同的 GC 算法：刚生成的对象称为新生代对象，对新对象执行的 GC 称为新生代 GC（minor GC），到达一定年龄的对象则称为老年代对象，面向老年代对象的 GC 称为老年代 GC（major GC），
新生代对象转为为老年代对象的情况称为晋升（promotion）。注：代数并不是划分的越多越好，虽然按照分代假说，如果分代数越多，最后抵达老年代的对象就越少，在老年代对象上消耗的垃圾回收的时间就越少，
但分代数增多会带来其他的开销，综合来看，代数划分为 2 代或者 3 代是最好的。

在经过新生代 GC 而晋升的对象把老年代空间填满之前，老年代 GC 都不会被执行。因此，老年代 GC 的执行频率要比新生代 GC 低。通过使用分代垃圾回收，可以改善 GC 所花费的时间（吞吐量）。

分代算法由于其普适性，已经被大多数的垃圾回收器采用（ZGC 目前不支持，但也在规划中了），其细节就不赘述了，这里我们主要关注引入分代算法后，GC 过程会出现哪些问题。

（1）问题1：不同分代在堆空间之中如何划分？

Ungar 提出的分代算法（论文：Generation Scavenging[7]）是目前使用最多的分代划分方案，该算法即为目前 CMS 垃圾回收器的原型：堆空间由 eden、survivor0/survivor1、old 共四个区域组成。
Ungar 的论文里新生代 GC 采用的是标记-复制算法，主要是利用该算法高吞吐的特性；老年代 GC 使用的是标记-清除算法，因为老年代空间比整体堆要小，如果使用标记-复制算法，能利用的堆空间会变得更小。

分代算法的堆空间组织方式，不只 Ungar 这一种方案。譬如，在一些基于 Ungar 的 Generation GC 的实现中，会把老年代的最后一个代通过标记-复制算法处理（Lisp Machine），
还有的算法会把最后一个代通过标记-压缩算法回收，降低复制算法出现的频繁换页的问题。

（2）问题2：如何标记代际之间的引用关系？

分代算法引入，需要考虑跨代/区之间对象引用的变化情况。新生代对象不只会被根对象和新生代里的对象引用，也可能被老年代对象引用，GC 算法需要做到「在不回收老年代对象的同时，安全地回收新生代里面的对象」
，新生代回收时，不适合也不可能去扫描整个老年代（变相搜索堆中的所有对象），否则就失去了对堆空间进行分代的意义了。

解决上述引用问题的关键是引入写屏障：如果一个老年代的引用指向了一个新生代的对象，就会触发写屏障。写屏障执行过程的伪代码如下所示，其中参数 obj 的成员变量为 field，
该变量将要被更新为 new_obj 所指向的对象，记录集 remembered_sets 被用于记录从老年代对象到新生代对象的引用，新生代 GC 时将会把记录集视为 GC Roots 的一部分。

在写入屏障里，首先会判断：

发出引用的对象是不是老年代对象；
目标引用标对象是不是新生代对象；
发出引用的对象是否还没有加入记录集。

如果满足以上三点，则本次新建的引用关系中，老年代的对象会被加入到记录集。上述过程可能会带来「浮动垃圾」，原因是所有由老年代->新生代的引用都会被加入记录集，但老年代内对象的存活性，
只有在下一次老年代GC 时才知道。

分代算法的优点在于减小了 GC 的作用范围后带来的高吞吐，但与此同时我们需要注意的是，其假说「绝大多数对象都是朝生夕灭的」并不适用于所有程序，在某些应用中，对象会活得很久，
如果在这样的场景下使用分代算法，老年代的 GC 就会很频繁，反而降低了 GC 的吞吐。此外，由于在记录代际引用关系时引入了写屏障，这也会带来一定的性能开销。

**增量算法（Incremental GC）**
增量算法对基础算法的改进主要体现在该算法通过并发的方式，降低了 STW 的时间。下图是增量算法和基础的标记-清除算法在执行时间线上的对比，可以看到，增量算法的核心思想是：
通过 GC 和应用程序交替执行的方式，来控制应用程序的最大暂停时间。

增量算法的「增量」部分，主要有「增量更新（Incremental Update）」和「增量拷贝（Incremental Copying）」两种，前者主要是做「标记」增量，后者是在做「复制」增量。

增量更新（Incremental Update）我们已经比较熟悉了，在介绍读/写屏障的时候，我们提到过由于存在并发，会出现对象漏标的情况。同样的，在增量算法中，由于 GC 线程和应用线程是交替执行的，
也会出现黑色节点指向白色节点的情况，增量算法中的漏标，同样是通过写屏障来解决的，主要有以下两种（基于快照的 SATB 也可以解决增量更新时出现的漏标，在此不再赘述）。

增量拷贝（Incremental Copying）大部分逻辑与标记-复制算法相似，还是会通过遍历引用关系图，把所有引用的对象拷贝到另一半堆内存，不过这个过程是并发执行的。当应用程序访问到老的堆空间对象时
，会触发读屏障，对象会从老的空间被拷贝至新的堆空间。

增量算法中大量使用了读写屏障（主要是写屏障），给应用程序带来了负担，结果就是 GC 的吞吐相较于其他的算法来说不高。

**并发算法（Concurrent GC）**
广义上的并发算法指的是在 GC 过程中存在并发阶段的算法，如 G1 中存在并发标记阶段，可将其整个算法视为并发算法。

狭义上的并发垃圾回收算法是以基础的标记-复制算法为基础，在各个阶段增加了并发操作实现的。与复制算法的3个阶段相对应，分为并发标记（mark）、并发转移（relocate）和并发重定位（remap）:

（1）并发标记

从 GC Roots 出发，使用遍历算法对对象的成员变量进行标记。同样的，并发标记也需要解决标记过程中引用关系变化导致的漏标记问题，这一点通过写屏障实现；

（2）并发转移

根据并发标记后的结果生成转移集合，把活跃对象转移（复制）到新的内存上，原来的内存空间可以回收，转移过程中会涉及到应用线程访问待转移对象的情况，一般的解决思路是加上读屏障，
在完成转移任务后，再访问对象；

（3）并发重定位

对象转移后其内存地址发生了变化，所有指向对象老地址的指针都要修正到新的地址上，这一步一般通过读屏障来实现。

并发算法是 ZGC、Shenandoah、C4 等垃圾回收器的算法基础，在具体的实现中，不同的垃圾回收器又有自己的选择和取舍。

至此，GC 算法的理论知识就告一段落了，有一些知识点是没有提到的，如部分标记-清除算法（Partial Mark & Sweep）的原理、保守式 GC（Conservative GC）对数据和指针的识别、
基于引用计数法的若干 GC 算法等
