### ZGC

# 什么是ZGC
ZGC（The Z Garbage Collector）是JDK 11 中推出的一款低延迟垃圾回收器，他的设计目标包括：

* 停顿时间不超过10ms
* 停顿时间不会随着堆的大小，或者活跃对象的大小二增加
* 支持8MB -- 4TB级别的堆

# 为什么会有ZGC
STW（Stop-The-world）问题是指所有应用线程在垃圾回收时被强制等待垃圾回收完成的现象，这就导致应用响应延迟，影响系统性能，特别是处理大量数据和高并发的请求场景下，STW问题特别突出。CMS和G1 GC都是使用的标记-复制算法，标记-复制算法中的转移阶段STW就会成为停顿时间的瓶颈。

# ZGC特点
* 1.目标
  ![image](https://github.com/user-attachments/assets/a1ce4f67-fc7f-4736-9b78-79ba5b7d6a35)

  低延迟保证：ZGC旨在将垃圾回收引起的暂停时间控制在毫秒级别，即使是TB级的内存，也能保持极低的停顿时间。

  并行和并发处理：ZGC充分利用多核处理器的能力，实现并行的垃圾回收操作，极大减少STW事件。

  可扩展性：支持GB到TB的堆大小，适应小型服务器到大规模集群的广泛场景。

  无碎片内存管理：通过实现无碎片内存分配和回收机制，避免内存碎片化问题。

  自适应调整：ZGC具备智能的自适应能力，可根据当前系统负载动态调整垃圾回收策略，确保不同工作负载下的性能表现。

  详尽的性能监控:提供丰富的垃圾回收日志和监控工具，帮助开发者理解当前行为，进行效率和性能调优。

# ZGC流程

1.初始标记

2.并发标记

3.再标记

4.并发转移

5.初始转移

6.并发转移

# ZGC 内存布局

ZGC没有了分代的概念（新生代、老年代），它拆分成支持3种页面（ZPages）：

![image](https://github.com/user-attachments/assets/933f087f-3ac8-4bfc-abe3-7d521fba167b)

2MB页面空间的小页面，存放小于等于256KB的对象。

32MB的中页面，存放256KB到4M之间的对象。

受操作系统控制的大页面，存放4M以上的对象。

# ZGC回收策略

* 小页面优先回收，中页面和大页面尽量不回收。

# ZGC--指针着色技术Colored Pointers

Colored Pointers主要用于解决并发垃圾回收的指针更新问题。ZGC使用了一种“指针压缩”技术，指针的一部分位置被用于存储额外的信息，让垃圾回收器进行高效的并发操作。

![image](https://github.com/user-attachments/assets/11b18ef2-3755-4a4c-8a9f-5987707443e5)

未标记（Unmarked）： 指针没有任何特殊标记，表示该对象还没有被垃圾回收器处理。

标记（Marked）： 指针被标记为已处理，表示该对象已经被垃圾回收器发现并处理过。

重定位（Relocated）： 指针被标记为已重定位，表示该对象已经被移动到新的内存位置，并且指针指向了新的位置。

* 标记阶段：

垃圾回收器遍历对象图，将发现的对象标记为 Marked。
如果对象需要被移动，垃圾回收器会将其标记为 Relocated，并将指针更新为新位置。

* 更新指针：

在并发阶段，应用程序线程继续运行，可能会修改对象图。
垃圾回收器需要确保在更新指针时不会丢失对已移动对象的引用。

* 清除阶段：

垃圾回收器清理未被标记的对象，释放内存。
通过这种方式，ZGC 能够在并发垃圾回收过程中高效地管理和追踪对象引用，减少停顿时间并提高整体性能。

经历两轮GC才会真正将垃圾清除，通过颜色指针的M0和M1交替标记，通过根可达算法标识存活对象，大批量的标记和转移都并发操作，用复制算法实现回收过程，最大限度减少STW停顿时间。

# ZGC--读屏障

之前的其他GC都是采用写屏障，ZGC采用读屏障，类似AOP中的前置通知。

在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为叫做指针的「自愈能力」。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW，类似JDK里的 CAS 自旋，读取的值发现已经失效了，需要重新读取。

# 总结

相比G1、Shenandoah等先进的垃圾收集器，ZGC在实现细节上做了一些不同的权衡选择。

譬如G1需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。

ZGC就完全没有使用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。

ZGC的这种选择也限制了它能承受的对象分配速率不会太高。

因为ZGC四个阶段都支持并发，如果分配速率高，将创造大量的新对象，这就产生了大量的浮动垃圾。如果这种高速分配持续维持的话，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。

目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。但是若要从根本上提升ZGC能够应对的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建。所以分代算法有利有弊。






